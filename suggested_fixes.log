expand
Now I can see the issues! There are several problems:

Problems Identified:
Document Parser Response Structure: The parser returns data wrapped in extracted_data, and you're storing the ENTIRE response (including message, timestamp, extracted_data, etc.) instead of just the JSON Resume schema fields.

Duplicate Data: The response has massive duplication - work experiences repeated 5 times, profiles repeated 5 times, etc.

Empty basics.profiles: The top-level basics.profiles is empty, but the actual profiles are in extracted_data.basics.profiles.

Wrong Return in autofillProfileFromResume(): Line 289 returns UserDto.fromEntity(user).getBasics() instead of the full profile.

Here's the fix:
java
@Override
public JsonNode autofillProfileFromResume(UUID userId, String resumeS3Url) {
    User user = userRepository.findById(userId)
            .orElseThrow(() -> new ResourceNotFoundException("User not found"));

    if (user.getRole() != Role.CANDIDATE) {
        throw new BadRequestException("Only candidates can autofill their profile from a resume");
    }

    // Call document parser to extract resume data
    JsonNode documentParserResponse = documentParserClient.extractResume(resumeS3Url);

    if (documentParserResponse == null || documentParserResponse.isNull() || documentParserResponse.isEmpty()) {
        logger.warn("Document parser returned no extracted profile data for resume: {}", resumeS3Url);
        return (user.getProfile() != null && !user.getProfile().isNull())
                ? user.getProfile() : objectMapper.createObjectNode();
    }

    // Extract ONLY the JSON Resume schema data from extracted_data
    JsonNode extractedData = documentParserResponse.get("extracted_data");
    if (extractedData == null || extractedData.isNull()) {
        logger.warn("No extracted_data found in document parser response");
        return (user.getProfile() != null && !user.getProfile().isNull())
                ? user.getProfile() : objectMapper.createObjectNode();
    }

    // Get current profile or create new one
    ObjectNode currentProfile = (user.getProfile() != null && !user.getProfile().isNull())
            ? (ObjectNode) user.getProfile().deepCopy() : objectMapper.createObjectNode();

    // Merge each section with deduplication
    mergeSection(currentProfile, extractedData, "basics");
    mergeArraySection(currentProfile, extractedData, "work");
    mergeArraySection(currentProfile, extractedData, "education");
    mergeArraySection(currentProfile, extractedData, "skills");
    mergeArraySection(currentProfile, extractedData, "projects");
    mergeArraySection(currentProfile, extractedData, "awards");
    mergeArraySection(currentProfile, extractedData, "certificates");
    mergeArraySection(currentProfile, extractedData, "interests");
    mergeArraySection(currentProfile, extractedData, "languages");
    mergeArraySection(currentProfile, extractedData, "publications");
    mergeArraySection(currentProfile, extractedData, "references");
    mergeArraySection(currentProfile, extractedData, "volunteer");

    // Preserve firstName and lastName from user entity in basics
    if (currentProfile.has("basics") && currentProfile.get("basics").isObject()) {
        ObjectNode basics = (ObjectNode) currentProfile.get("basics");
        if (user.getFirstName() != null) {
            String fullName = user.getFirstName() + (user.getLastName() != null ? " " + user.getLastName() : "");
            basics.put("name", fullName);
        }
        if (user.getEmail() != null) {
            basics.put("email", user.getEmail());
        }
    }

    user.setProfile(currentProfile);
    user.setProfileComplete(true);
    userRepository.save(user);

    logger.info("Profile autofilled for user {} from resume: {}", userId, resumeS3Url);
    return currentProfile; // Return the full profile, not just basics
}

// Helper method to merge a single section (like basics)
private void mergeSection(ObjectNode target, JsonNode source, String sectionName) {
    JsonNode sourceSection = source.get(sectionName);
    if (sourceSection == null || sourceSection.isNull()) {
        return;
    }

    if (target.has(sectionName) && target.get(sectionName).isObject() && sourceSection.isObject()) {
        mergeJsonNodes((ObjectNode) target.get(sectionName), sourceSection);
    } else {
        target.set(sectionName, sourceSection.deepCopy());
    }
}

// Helper method to merge and deduplicate array sections
private void mergeArraySection(ObjectNode target, JsonNode source, String sectionName) {
    JsonNode sourceArray = source.get(sectionName);
    if (sourceArray == null || !sourceArray.isArray() || sourceArray.isEmpty()) {
        return;
    }

    ArrayNode targetArray;
    if (target.has(sectionName) && target.get(sectionName).isArray()) {
        targetArray = (ArrayNode) target.get(sectionName);
    } else {
        targetArray = objectMapper.createArrayNode();
        target.set(sectionName, targetArray);
    }

    // Deduplicate by converting to Set using JSON string representation
    List<JsonNode> uniqueItems = new ArrayList<>();
    List<String> seenItems = new ArrayList<>();

    // Add existing items
    for (JsonNode item : targetArray) {
        String itemStr = item.toString();
        if (!seenItems.contains(itemStr)) {
            uniqueItems.add(item);
            seenItems.add(itemStr);
        }
    }

    // Add new items from source, skipping duplicates
    for (JsonNode item : sourceArray) {
        String itemStr = item.toString();
        if (!seenItems.contains(itemStr)) {
            uniqueItems.add(item);
            seenItems.add(itemStr);
        }
    }

    // Rebuild array with unique items
    targetArray.removeAll();
    uniqueItems.forEach(targetArray::add);
}

// Update the existing mergeJsonNodes to handle profiles properly
private void mergeJsonNodes(ObjectNode mainNode, JsonNode updateNode) {
    updateNode.fields().forEachRemaining(entry -> {
        String fieldName = entry.getKey();
        JsonNode updateValue = entry.getValue();

        // Skip these fields as they come from user entity
        if ("name".equals(fieldName) || "email".equals(fieldName)) {
            return;
        }

        if (mainNode.has(fieldName)) {
            JsonNode mainValue = mainNode.get(fieldName);

            if (mainValue.isObject() && updateValue.isObject()) {
                mergeJsonNodes((ObjectNode) mainValue, updateValue);
            } else if (mainValue.isArray() && updateValue.isArray()) {
                // For arrays in basics (like profiles), deduplicate
                ArrayNode mainArray = (ArrayNode) mainValue;
                ArrayNode updateArray = (ArrayNode) updateValue;

                List<String> seenItems = new ArrayList<>();
                for (JsonNode item : mainArray) {
                    seenItems.add(item.toString());
                }

                for (JsonNode item : updateArray) {
                    String itemStr = item.toString();
                    if (!seenItems.contains(itemStr)) {
                        mainArray.add(item);
                        seenItems.add(itemStr);
                    }
                }
            } else {
                mainNode.set(fieldName, updateValue);
            }
        } else {
            mainNode.set(fieldName, updateValue.deepCopy());
        }
    });
}
Key changes:

Extract only extracted_data from the document parser response, ignoring metadata fields
Deduplicate arrays using string comparison
Return the full profile instead of just basics
Preserve user's name and email in basics section
Properly merge basics.profiles with deduplication
This should fix the /me endpoint to return a clean, deduplicated JSON Resume structure with profiles properly nested under basics!